<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Linux,SSH,password,forward," />





  <link rel="alternate" href="/atom.xml" title="plantegg" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="史上最全 SSH 暗黑技巧详解我见过太多的老鸟、新手对ssh 基本只限于 ssh到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。 疫情期间一行SSH命令让我节省了70%的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界">
<meta name="keywords" content="Linux,SSH,password,forward">
<meta property="og:type" content="article">
<meta property="og:title" content="史上最全 SSH 暗黑技巧详解">
<meta property="og:url" content="https://plantegg.github.io/2019/06/02/史上最全_SSH_暗黑技巧详解--收藏保平安/index.html">
<meta property="og:site_name" content="plantegg">
<meta property="og:description" content="史上最全 SSH 暗黑技巧详解我见过太多的老鸟、新手对ssh 基本只限于 ssh到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。 疫情期间一行SSH命令让我节省了70%的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界">
<meta property="og:image" content="https://plantegg.github.io/images/oss/e4a2fdad5b04542dc657b96e195a2b45.png">
<meta property="og:image" content="https://plantegg.github.io/images/oss/1561367815573-0b793473-67fa-4edc-ae58-04e7c4c51b87.png">
<meta property="og:image" content="https://plantegg.github.io/images/oss/1acbd09b4b45dbd478ddabc0e001a15e.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/S9jLW7B.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/4SZcnvc.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210902224011450.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/ssh-tunnels.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210913143129749.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/vgaakWbKC9OPXugAR9oPnotTq1L4jBRDEg.JPG">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/image-20210913163036410.png">
<meta property="og:image" content="https://plantegg.github.io/images/951413iMgBlog/step-certificate-inspect.png">
<meta property="og:updated_time" content="2023-02-22T06:02:20.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="史上最全 SSH 暗黑技巧详解">
<meta name="twitter:description" content="史上最全 SSH 暗黑技巧详解我见过太多的老鸟、新手对ssh 基本只限于 ssh到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。 疫情期间一行SSH命令让我节省了70%的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界">
<meta name="twitter:image" content="https://plantegg.github.io/images/oss/e4a2fdad5b04542dc657b96e195a2b45.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://plantegg.github.io/2019/06/02/史上最全_SSH_暗黑技巧详解--收藏保平安/"/>





  <title>史上最全 SSH 暗黑技巧详解 | plantegg</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">plantegg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">java tcp mysql performance network docker Linux</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://plantegg.github.io/2019/06/02/史上最全_SSH_暗黑技巧详解--收藏保平安/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="twitter @plantegg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="plantegg">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">史上最全 SSH 暗黑技巧详解</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T17:30:03+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSH/" itemprop="url" rel="index">
                    <span itemprop="name">SSH</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="史上最全-SSH-暗黑技巧详解"><a href="#史上最全-SSH-暗黑技巧详解" class="headerlink" title="史上最全 SSH 暗黑技巧详解"></a>史上最全 SSH 暗黑技巧详解</h1><p>我见过太多的老鸟、新手对ssh 基本只限于 ssh到远程机器，实际这个命令我们一天要用很多次，但是对它的了解太少了，他的强大远远超出你的想象。当于你也许会说够用就够了，确实没错，但是你考虑过效率没有，或者还有哪些脑洞大开的功能会让你爱死他，这些功能又仅仅是一行命令就够了。</p>
<p>疫情期间一行SSH命令让我节省了70%的出差时间，来，让我们一起走一遍，看看会不会让你大开眼界</p>
<h2 id="本文试图解决的问题"><a href="#本文试图解决的问题" class="headerlink" title="本文试图解决的问题"></a>本文试图解决的问题</h2><ul>
<li>如何通过ssh命令科学上网</li>
<li>docker 镜像、golang仓库总是被墙怎么办</li>
<li>公司跳板机要输入动态token，太麻烦了，如何省略掉这个token；</li>
<li>比如多机房总是要走跳板机，如何<code>绕过</code>跳板机直连； </li>
<li>我的开发测试机器如何免打通、免密码、直达；</li>
<li>如何访问隔离环境中(k8s)的Web服务 – 将隔离环境中的web端口映射到本地</li>
<li>如何让隔离环境的机器用上yum、apt</li>
<li>如何将服务器的图形界面映射到本地(类似vnc的作用)</li>
<li>ssh如何调试诊断，这才是终极技能……</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>ssh是指的openSSH 命令工具</li>
<li>本文适用于各种Linux、MacOS下命令行操作，Windows的话各种可视化工具都可以复制session、配置tunnel来实现类似功能。</li>
<li>如果文章中提到的文件、文件夹不存在可以直接创建出来。</li>
<li>所有配置都是在你的笔记本上（相当于ssh client上）</li>
</ul>
<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>有时候科学上网还得靠自己，一行ssh命令来科学上网:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssh -qTfnN -D 127.0.0.1:38080 root@1.1.1.1 &quot;vmstat 10&quot; 2&gt;&amp;1 &gt;/dev/null &amp;</div></pre></td></tr></table></figure>
<p>上面的 1.1.1.1 是你在境外的一台服务器，已经做好了免密登陆（免密见后面，要不你还得输一下密码），这句话的意思就是在本地启动一个38080的端口，上面收到的任何东西都会转发给 1.1.1.1:22（做了ssh加密），1.1.1.1:22 会解密收到的东西，然后把他们转发给google之类的网站（比如你要访问的是google），结果依然通过原路返回</p>
<p>127.0.0.1:38080  socks5 就是要填入到你的浏览器中的代理服务器，什么都不需要装，非常简单</p>
<p><img src="/images/oss/e4a2fdad5b04542dc657b96e195a2b45.png" alt="image.png"></p>
<p>原理图如下(灰色矩形框就是你本地ssh命令，ssh 线就是在穿墙， 国外服务器就是命令中的1.1.1.1)：<br><img src="/images/oss/1561367815573-0b793473-67fa-4edc-ae58-04e7c4c51b87.png" alt="undefined"> </p>
<h3 id="科学上网之http特殊代理–利用ssh-本地转发是HTTP协议"><a href="#科学上网之http特殊代理–利用ssh-本地转发是HTTP协议" class="headerlink" title="科学上网之http特殊代理–利用ssh 本地转发是HTTP协议"></a>科学上网之http特殊代理–利用ssh 本地转发是HTTP协议</h3><p>前面所说的代理是socks5代理，一般浏览器都有插件支持，但是比如你的docker（或者其他程序）需要通过http去拉取镜像就会出现如下错误：</p>
<pre><code>Sending build context to Docker daemon 8.704 kB
Step 1 : FROM k8s.gcr.io/kube-cross:v1.10.1-1
Get https://k8s.gcr.io/v1/_ping: dial tcp 108.177.125.82:443: i/o timeout
</code></pre><p><a href="https://www.atatech.org/articles/102153" target="_blank" rel="external">如果是git这样的应用内部可以配置socks5和http代理服务器，请参考另外一篇文章</a>，但是有些应用就不能配置了，当然最终通过ssh大法还是可以解决这个问题：</p>
<pre><code>sudo ssh -L 443:108.177.125.82:443 root@1.1.1.1 //在本地监听443，转发给远程108.177.125.82的443端口
</code></pre><p>然后再在 /etc/hosts 中将域名 k8s.gcr.io 指向 127.0.0.1， 那么本来要访问 k8s.gcr.io:443的，变成了访问本地 127.0.0.1:443 而 127.0.0.1:443 又通过ssh重定向到了 108.177.125.82:443 这样就实现了http代理或者说这种特殊情况下的科学上网。这个方案不需要装任何东西，但是每个访问目标都要这样处理，好在这种情况不多</p>
<h2 id="内部堡垒机、跳板机都需要密码-动态码，太复杂了，怎么解？"><a href="#内部堡垒机、跳板机都需要密码-动态码，太复杂了，怎么解？" class="headerlink" title="内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？"></a>内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cat ~/.ssh/config </div><div class="line"><span class="meta">#</span>reuse the same connection --关键配置</div><div class="line">ControlMaster auto</div><div class="line">ControlPath ~/tmp/ssh_mux_%h_%p_%r</div><div class="line"><span class="meta"></span></div><div class="line">#查了下ControlPersist是在OpenSSH5.6加入的，5.3还不支持</div><div class="line"><span class="meta">#</span>不支持的话直接把这行删了，不影响功能</div><div class="line"><span class="meta">#</span>keep one connection in 72hour</div><div class="line"><span class="meta">#</span>ControlPersist 72h</div><div class="line"><span class="meta">#</span>复用连接的配置到这里，后面的配置与复用无关</div><div class="line"><span class="meta"></span></div><div class="line">#其它也很有用的配置</div><div class="line">GSSAPIAuthentication=no</div><div class="line"><span class="meta">#</span>这个配置在公网因为安全原因请谨慎关闭</div><div class="line">StrictHostKeyChecking=no</div><div class="line">TCPKeepAlive=yes</div><div class="line">CheckHostIP=no</div><div class="line"><span class="meta">#</span> "ServerAliveInterval [seconds]" configuration in the SSH configuration so that your ssh client sends a "dummy packet" on a regular interval so that the router thinks that the connection is active even if it's particularly quiet</div><div class="line">ServerAliveInterval=15</div><div class="line"><span class="meta">#</span>ServerAliveCountMax=6</div><div class="line">ForwardAgent=yes</div><div class="line"></div><div class="line">UserKnownHostsFile /dev/null</div></pre></td></tr></table></figure>
<p>在你的ssh配置文件增加上述参数，意味着72小时内登录同一台跳板机只有第一次需要输入密码，以后都是重用之前的连接，所以也就不再需要输入密码了。</p>
<p>加了如上参数后的登录过程就有这样的东东(默认没有，这是debug信息)：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">debug1: setting up multiplex master socket</div><div class="line">debug3: muxserver_listen: temporary control path   /home/ren/tmp/ssh_mux_10.16.*.*_22_corp.86g3C34vy36tvCtn</div><div class="line">debug2: fd 3 setting O_NONBLOCK</div><div class="line">debug3: fd 3 is O_NONBLOCK</div><div class="line">debug3: fd 3 is O_NONBLOCK</div><div class="line">debug1: channel 0: new [/home/ren/tmp/ssh_mux_10.16.*.*_22_corp]</div><div class="line">debug3: muxserver_listen: mux listener channel 0 fd 3</div><div class="line">debug1: control_persist_detach: backgrounding master process</div><div class="line">debug2: control_persist_detach: background process is 15154</div><div class="line">debug2: fd 3 setting O_NONBLOCK</div><div class="line">debug1: forking to background</div><div class="line">debug1: Entering interactive session.</div><div class="line">debug2: set_control_persist_exit_time: schedule exit in 259200 seconds</div><div class="line">debug1: multiplexing control connection</div></pre></td></tr></table></figure>
<p> /home/ren/tmp/ssh_mux_10.16.<em>.</em>_22_corp 这个就是保存好的socket，下次可以重用，免密码。 in 259200 seconds 对应 72小时</p>
<h2 id="我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？"><a href="#我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？" class="headerlink" title="我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？"></a>我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？</h2><p>比如有一批客户机房的机器IP都是192.168.<em>.</em>, 然后需要走跳板机100.10.1.2才能访问到，那么我希望以后<strong>在笔记本上直接 ssh 192.168.1.5 就能直接连上</strong></p>
<pre><code>$ cat /etc/ssh/ssh_config

Host 192.168.*.*
ProxyCommand ssh -l ali-renxijun 100.10.1.2 exec /usr/bin/nc %h %p
</code></pre><p>上面配置的意思是执行 ssh 192.168.1.5的时候命中规则 Host 192.168.<em>.</em> 所以执行 ProxyCommand 先连上跳板机再通过跳板机连向192.168.1.5 。这样在你的笔记本上就跟192.168.<em>.</em> 的机器仿佛在一起，ssh可以上去，但是ping不通这个192.168.1.5的ip</p>
<p><strong>划重点：公司的线上跳板机做了特殊限制，限制了这个技能。日常环境跳板机支持这个功能</strong></p>
<p>比如我的跳板配置：</p>
<pre><code>#到美国的机器用美国的跳板机速度更快
Host 10.74.*
ProxyCommand ssh -l user us.jump exec /bin/nc %h %p 2&gt;/dev/null
#到中国的机器用中国的跳板机速度更快
Host 10.70.*
ProxyCommand ssh -l user cn.jump exec /bin/nc %h %p 2&gt;/dev/null

Host 192.168.0.*
ProxyCommand ssh -l user 1.1.1.1 exec /usr/bin/nc %h %p
</code></pre><p>其实我的配置文件里面还有很多规则，懒得一个个隐藏IP了，这些规则是可以重复匹配的</p>
<p>来看一个例子    </p>
<pre><code>ren@ren-VirtualBox:/$ ping -c 1 10.16.1.*
        PING 10.16.1.* (10.16.1.*) 56(84) bytes of data.^C
    --- 10.16.1.* ping statistics ---
    1 packets transmitted, 0 received, 100% packet loss, time 0ms

ren@ren-VirtualBox:~$ ssh -l corp 10.16.1.* -vvv
OpenSSH_6.7p1 Ubuntu-5ubuntu1, OpenSSL 1.0.1f 6 Jan 2014
debug1: Reading configuration data /home/ren/.ssh/config
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 28: Applying options for *
debug1: /etc/ssh/ssh_config line 44: Applying options for 10.16.*.*
debug1: /etc/ssh/ssh_config line 68: Applying options for *
debug1: auto-mux: Trying existing master
debug1: Control socket &quot;/home/ren/tmp/ssh_mux_10.16.1.*_22_corp&quot; does not exist
debug1: Executing proxy command: exec ssh -l corp 139.*.*.* exec /usr/bin/nc 10.16.1.* 22
</code></pre><p>本来我的笔记本跟 10.16.1.<em> 是不通的(ping 不通），但是ssh可以直接连上，实际ssh登录过程中自动走跳板机139.</em>.<em>.</em> 就连上了</p>
<p>-vvv 参数是debug，把ssh登录过程的日志全部打印出来。 </p>
<h2 id="将隔离环境中的web端口映射到本地（本地代理）"><a href="#将隔离环境中的web端口映射到本地（本地代理）" class="headerlink" title="将隔离环境中的web端口映射到本地（本地代理）"></a>将隔离环境中的web端口映射到本地（本地代理）</h2><p>远程机器部署了WEB Server，需要通过浏览器来访问这个WEB服务，但是server在隔离环境中，只能通过ssh访问到。一般来说会在隔离环境中部署一个windows机器，通过这个windows机器来访问到这个web server。能不能省掉这个windows机器呢？</p>
<p>现在我们试着用ssh来实现本地浏览器直接访问到这个隔离环境中的WEB Server。</p>
<p>假设web server是：10.1.1.123:8083， ssh账号是：user</p>
<p>先配置好本地直接 ssh user@10.1.1.123 （参考前面的 ProxyCommand配置过程，最好是免密也配置好），然后在你的笔记本上执行：</p>
<pre><code>ssh -CNfL 0.0.0.0:8088:10.1.1.123:8083 user@10.1.1.123
</code></pre><p>或者：(root@100.1.2.3 -p 54900 是可达10.1.1.123的代理服务器)</p>
<pre><code>ssh -CNfL 0.0.0.0:8089:10.1.1.123:8083 root@100.1.2.3 -p 54900
</code></pre><p>这表示在本地启动一个8088的端口，将这个8088端口映射到10.1.1.123的8083端口上，用的ssh账号是user</p>
<p>然后在笔记本上的浏览器中输入： 127.0.0.1：8088 就看到了如下界面：</p>
<p><img src="/images/oss/1acbd09b4b45dbd478ddabc0e001a15e.png" alt="image.png"></p>
<p>反过来，<strong>也可以让隔离环境机器通过代理上网，比如安装yum</strong></p>
<h2 id="为什么有时候ssh-比较慢，比如总是需要30秒钟后才能正常登录"><a href="#为什么有时候ssh-比较慢，比如总是需要30秒钟后才能正常登录" class="headerlink" title="为什么有时候ssh 比较慢，比如总是需要30秒钟后才能正常登录"></a>为什么有时候ssh 比较慢，比如总是需要30秒钟后才能正常登录</h2><p>先了解如下知识点，在 ~/.ssh/config 配置文件中：</p>
<pre><code>GSSAPIAuthentication=no
</code></pre><p>禁掉 GSSAPI认证，GSSAPIAuthentication是个什么鬼东西请自行 Google(多一次没必要的授权认证过程，然后等待超时)。 这里要理解ssh登录的时候有很多种认证方式（公钥、密码等等），具体怎么调试请记住强大的命令参数 ssh -vvv 上面讲到的技巧都能通过 -vvv 看到具体过程。</p>
<p>比如我第一次碰到ssh 比较慢总是需要30秒后才登录，不能忍受，于是登录的时候加上 -vvv明显看到控制台停在了：GSSAPIAuthentication 然后Google了一下，禁掉就好了</p>
<p>当然还有去掉每次ssh都需要先输入yes</p>
<h2 id="批量打通所有机器之间的ssh登录免密码"><a href="#批量打通所有机器之间的ssh登录免密码" class="headerlink" title="批量打通所有机器之间的ssh登录免密码"></a>批量打通所有机器之间的ssh登录免密码</h2><p><strong>Expect在有些公司是被禁止的</strong></p>
<p>ssh免密码的原理是将本机的pub key复制到目标机器的 ~/.ssh/authorized_keys 里面。可以手工复制粘贴，也可以 ssh-copy-id 等</p>
<p>如果有100台机器，互相两两打通还是比较费事（大概需要100*99次copy key）。 下面通过 expect 来解决输入密码，然后配合shell脚本来批量解决这个问题。</p>
<p><img src="/images/951413iMgBlog/S9jLW7B.png" alt=""></p>
<p>这个脚本需要四个参数：目标IP、用户名、密码、home目录，也就是ssh到一台机器的时候帮我们自动填上yes，和密码，这样就不需要人肉一个个输入了。</p>
<p>再在外面写一个循环对每个IP执行如下操作：</p>
<p><img src="/images/951413iMgBlog/4SZcnvc.png" alt=""></p>
<p>if代码部分检查本机~/.ssh/下有没有id_rsa.pub，也就是是否以前生成过密钥对，没生成的话就帮忙生成一次。</p>
<p>for循环部分一次把生成的密钥对和authorized_keys复制到所有机器上，这样所有机器之间都不需要输入密码就能互相登陆了（当然本机也不需要输入密码登录所有机器）</p>
<p>最后一行代码： </p>
<pre><code>ssh $user@$n &quot;hostname -i&quot;
</code></pre><p>验证一下没有输密码是否能成功ssh上去。</p>
<p><strong>思考一下，为什么这么做就可以打通两两之间的免密码登录，这里没有把所有机器的pub key复制到其他所有机器上去啊</strong></p>
<blockquote>
<p>答案：其实这个脚本做了一个取巧投机的事，那就是让所有机器共享一套公钥、私钥。<br>有时候我也会把我的windows笔记本和我专用的某台虚拟机共享一套秘钥，这样任何新申请的机器打通一次账号就可以在两台机器上随便登录。请保护好自己的私钥</p>
</blockquote>
<p>如果免密写入 authorized_keys 成功，但是通过ssh pubkey认证的时候还是有可能失败，这是因为pubkey认证要求：</p>
<ul>
<li>authorized_keys  文件权限要对</li>
<li>.ssh 文件夹权限要对</li>
<li>/home/user 文件夹权限要对 —-这个容易忽视掉</li>
</ul>
<h2 id="留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？"><a href="#留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？" class="headerlink" title="留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？"></a>留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？</h2><blockquote>
<p>StrictHostKeyChecking=no<br>UserKnownHostsFile=/dev/null</p>
</blockquote>
<p>如果按照文章操作不work，推荐就近问身边的同学。问我的话请cat 配置文件  然后把ssh -vvv user@ip (user、ip请替换成你的），再截图发给我。**</p>
<p>测试成功的同学也请留言说下什么os、版本，以及openssl版本，我被问崩溃了</p>
<hr>
<p><strong>这里只是帮大家入门了解ssh，掌握好这些配置文件和-vvv后有好多好玩的可以去挖掘，同时也请在留言中说出你的黑技能</strong></p>
<h2 id="ssh-config-参考配置"><a href="#ssh-config-参考配置" class="headerlink" title="~/.ssh/config 参考配置"></a>~/.ssh/config 参考配置</h2><p>下面是我个人常用的ssh config配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>cat ~/.ssh/config</div><div class="line"><span class="meta">#</span>GSSAPIAuthentication=no</div><div class="line">StrictHostKeyChecking=no</div><div class="line"><span class="meta">#</span>TCPKeepAlive=yes</div><div class="line">CheckHostIP=no</div><div class="line"><span class="meta">#</span> "ServerAliveInterval [seconds]" configuration in the SSH configuration so that your ssh client sends a "dummy packet" on a regular interval so that the router thinks that the connection is active even if it's particularly quiet</div><div class="line">ServerAliveInterval=15</div><div class="line"><span class="meta">#</span>ServerAliveCountMax=6</div><div class="line">ForwardAgent=yes</div><div class="line"></div><div class="line">UserKnownHostsFile /dev/null</div><div class="line"><span class="meta"></span></div><div class="line">#reuse the same connection</div><div class="line">ControlMaster auto</div><div class="line">ControlPath /tmp/ssh_mux_%h_%p_%r</div><div class="line"><span class="meta"></span></div><div class="line">#keep one connection in 72hour</div><div class="line">ControlPersist 72h</div><div class="line"></div><div class="line">Host 192.168.1.*</div><div class="line">ProxyCommand ssh user@us.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</div><div class="line">Host 192.168.2.*</div><div class="line">ProxyCommand ssh user@cn.jump exec /usr/bin/nc %h %p 2&gt;/dev/null</div><div class="line"><span class="meta">#</span>ProxyCommand /bin/nc -x localhost:12346 %h %p</div><div class="line"></div><div class="line">Host 172</div><div class="line">    HostName 10.172.1.1</div><div class="line">    Port 22</div><div class="line">    User root</div><div class="line">    ProxyJump root@1.2.3.4:12345</div><div class="line"></div><div class="line">Host 176</div><div class="line">    HostName 10.176.1.1</div><div class="line">    Port 22</div><div class="line">    User root</div><div class="line">    ProxyJump admin@1.2.3.4:12346</div><div class="line">    </div><div class="line">Host 10.5.*.*, 10.*.*.*</div><div class="line">    port 22</div><div class="line">			user root</div><div class="line">			ProxyJump plantegg@1.2.3.4:12347</div></pre></td></tr></table></figure>
<p>ProxyJump完全可以取代 ProxyCommand，比如ProxyJump 不再依赖nc、也更灵活一些</p>
<h2 id="etc-ssh-ssh-config-参考配置"><a href="#etc-ssh-ssh-config-参考配置" class="headerlink" title="/etc/ssh/ssh_config 参考配置"></a>/etc/ssh/ssh_config 参考配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Host *</div><div class="line">Protocol 2</div><div class="line">ServerAliveInterval 30</div><div class="line">User admin</div><div class="line"></div><div class="line">host 10.10.55.*</div><div class="line">ProxyCommand ssh -l admin admin.jump  exec /usr/bin/nc %h %p</div><div class="line"></div><div class="line"># uos is a hostname</div><div class="line">Host 10.10.1.13* 192.168.2.133 uos</div><div class="line">ProxyCommand ssh -l root -p 54900 1.1.1.1 exec /usr/bin/nc %h %p</div><div class="line"></div><div class="line">#debug for git proxy</div><div class="line">Host github.com</div><div class="line">#    LogLevel DEBUG3</div><div class="line">#    ProxyCommand ssh  -l root gfw.jump exec /usr/bin/nc %h %p</div><div class="line">#    ProxyCommand ssh -oProxyCommand=&apos;ssh -l admin gfw.jump:22&apos; -l root gfw.jump2 exec /usr/bin/nc %h %p</div><div class="line"></div><div class="line"></div><div class="line">ForwardAgent yes</div><div class="line">ForwardX11 yes</div><div class="line">ForwardX11Trusted yes</div><div class="line"></div><div class="line">    SendEnv LANG LC_*</div><div class="line">    HashKnownHosts yes</div><div class="line">    GSSAPIAuthentication no</div><div class="line">    GSSAPIDelegateCredentials no</div><div class="line">    Compression yes</div></pre></td></tr></table></figure>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><p>参数的优先级是：命令行配置选项 &gt; ~/.ssh/config &gt; /etc/ssh/ssh_config</p>
<p>在SSH的<strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式，</strong>所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥（阿里云服务器秘钥对–服务器将一对密钥中的公钥放在 authorized_keys, 私钥给client登陆用）</p>
<p>服务器上的 /etc/ssh/ssh_host<em> 是用来验证服务器身份的秘钥对（对应client的 known_hosts), <em>*在主机验证阶段，服务端持有的是私钥，客户端保存的是来自于服务端的公钥。注意，这和身份验证阶段密钥的持有方是相反的。</em></em></p>
<p>SSH支持多种身份验证机制，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制(password)和公钥认证机制(public key). 当公钥认证机制未通过时，再进行密码认证机制的验证。这些认证顺序可以通过ssh配置文件(注意，不是sshd的配置文件)中的指令PreferredAuthentications改变。</p>
<h3 id="永久隧道"><a href="#永久隧道" class="headerlink" title="永久隧道"></a>永久隧道</h3><p>大多时候隧道会失效，或者断开，我们需要有重连机制，一般可以通过autossh（需要单独安装）搞定自动重连，再配合systemd或者crond搞定永久自动重连</p>
<p>比如以下代码在gf开启2个远程转发端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">remote_port=(30081 30082)</div><div class="line">for port in &quot;$&#123;remote_port[@]&#125;&quot;</div><div class="line">do</div><div class="line">    line=`ps aux |grep ssh |grep $port | wc -l`</div><div class="line">    if [[ &quot;$line&quot; -lt 1 ]]; then</div><div class="line">        autossh -M 0 -fNR gf:$port:127.0.0.1:22 root@gf</div><div class="line">    fi;</div><div class="line">done</div><div class="line"></div><div class="line">line=`ps aux |grep ssh |grep 13129 | wc -l`</div><div class="line">if [[ &quot;$line&quot; -lt 1 ]]; then</div><div class="line">    nohup ssh -fNR gf:13129:172.16.1.2:3129 root@gf</div><div class="line">fi;</div><div class="line"></div><div class="line">#cat /etc/cron.d/jump</div><div class="line">#* * * * * root sh /root/drds_private_cloud/jump.sh</div></pre></td></tr></table></figure>
<p>或者另外创建一个service服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=AutoSSH tunnel on 31081 to gf server</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Environment=&quot;AUTOSSH_GATETIME=0&quot;</div><div class="line">ExecStart=/usr/bin/autossh -M 0 -q -N -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -NR gf:31081:172.16.1.2:22 -i /root/.ssh/id_rsa root@gf</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure>
<h3 id="调试ssh–终极大招"><a href="#调试ssh–终极大招" class="headerlink" title="调试ssh–终极大招"></a>调试ssh–终极大招</h3><p>好多问题我都是debug发现的</p>
<ul>
<li>客户端增加参数 -vvv 会把所有流程在控制台显示出来。卡在哪个环节；密码不对还是key不对一看就知道</li>
<li>server端还可以：/usr/sbin/sshd -ddd -p 2222 在2222端口对sshd进行debug，看输出信息验证为什么pub key不能login等. 一般都是权限不对，/root 以及 /root/.ssh 文件夹的权限和owner都要对，更不要说 /root/.ssh/authorized_keys 了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/sbin/sshd -ddd -p 2222</div></pre></td></tr></table></figure>
<h3 id="ssh-提示信息"><a href="#ssh-提示信息" class="headerlink" title="ssh 提示信息"></a><a href="https://www.tecmint.com/ssh-warning-banner-linux/" target="_blank" rel="external">ssh 提示信息</a></h3><p>可以用一下脚本生成一个彩色文件，放到 /etc/motd 中就行</p>
<p>Basic colors are numbered:</p>
<ul>
<li>1 – Red</li>
<li>2 – Green</li>
<li>3 – Yellow</li>
<li>4 – Blue</li>
<li>5 – Magenta</li>
<li>6 – Cyan</li>
<li>7 – White</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/sh</div><div class="line">export TERM=xterm-256color</div><div class="line"></div><div class="line">read one five fifteen rest &lt; /proc/loadavg</div><div class="line">echo "$(tput setaf 2)</div><div class="line">Kernel: `uname -v | awk -v OFS=' ' '&#123;print $4, $5&#125;'`</div><div class="line">                                                                                                                                   </div><div class="line">        \\   ^__^</div><div class="line">         \\  (oo)\\_______</div><div class="line">            (__)\\       )\\\/\\</div><div class="line">                ||----w |</div><div class="line">                ||     ||</div><div class="line"></div><div class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</div><div class="line"></div><div class="line">有任何需要请联系 ** 多谢!</div><div class="line"><span class="meta"></span></div><div class="line">$(tput setaf 4)Load Averages......: $&#123;one&#125;, $&#123;five&#125;, $&#123;fifteen&#125; (1, 5, 15 min)</div><div class="line"><span class="meta">$</span>(tput setaf 5)</div><div class="line"> ______________</div><div class="line">本机器为长稳测试环境, 千万不要kill进程, 不要跑负载过重的任务</div><div class="line"></div><div class="line">有任何需要请联系 ** 多谢!</div><div class="line"> --------------</div><div class="line">        \\   ^__^</div><div class="line">         \\  (oo)\\_______</div><div class="line">            (__)\\       )\\\/\\</div><div class="line">                ||----w |</div><div class="line">                ||     ||</div><div class="line"><span class="meta"></span></div><div class="line">$(tput sgr0)"</div></pre></td></tr></table></figure>
<p>以上脚本运行结果</p>
<p><img src="/images/951413iMgBlog/image-20210902224011450.png" alt="image-20210902224011450"></p>
<h3 id="sshd-Banner"><a href="#sshd-Banner" class="headerlink" title="sshd Banner"></a>sshd Banner</h3><p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p>
<p>或者配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat /etc/ssh/sshd_config</div><div class="line"># no default banner path</div><div class="line">#Banner none</div><div class="line">#在配置文件末尾添加Banner /etc/ssh/my_banner这一行内容：</div><div class="line">Banner /etc/ssh/my_banner</div></pre></td></tr></table></figure>
<p>/etc/ssh/my_banner 中可以放置提示内容</p>
<h3 id="验证秘钥对"><a href="#验证秘钥对" class="headerlink" title="验证秘钥对"></a>验证秘钥对</h3><p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p>
<blockquote>
<p>cd ~/.ssh/ ; ssh-keygen -y -f id_rsa | cut -d’ ‘ -f 2  ;  cut -d’ ‘ -f 2 id_rsa.pub</p>
</blockquote>
<p><code>ssh-keygen -y -e -f &lt;private key&gt;</code>获取一个私钥并打印相应的公钥，该公钥可以直接与您可用的公钥进行比较</p>
<h3 id="github-上你的公钥"><a href="#github-上你的公钥" class="headerlink" title="github 上你的公钥"></a>github 上你的公钥</h3><p>github可以取到你的公钥，如果别人让你查看他的服务器，直接给 <a href="https://github.com/plantegg.keys这个链接，让他把下载的key" target="_blank" rel="external">https://github.com/plantegg.keys这个链接，让他把下载的key</a> 加到 ~/.ssh/authorized_keys 里面就行了</p>
<h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a><a href="https://superuser.com/questions/1416315/how-can-i-convert-a-public-key-generated-by-putty-to-rfc-4716-format" target="_blank" rel="external">ssh-keygen</a></h3><p><a href="https://stackoverflow.com/questions/43235179/how-to-execute-ssh-keygen-without-prompt" target="_blank" rel="external">静默生成</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y</div><div class="line"></div><div class="line">ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &lt;&lt;&lt;y &gt;/dev/null 2&gt;&amp;1</div><div class="line"></div><div class="line">//修改 passphrase</div><div class="line">ssh-keygen -p -P "12345" -N "abcde" -f .ssh/id_rsa</div><div class="line">//ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]</div><div class="line">//或者直接通过提示一步步修改：</div><div class="line">ssh-keygen -p</div></pre></td></tr></table></figure>
<p>删除或者修改 passphrase</p>
<blockquote>
<p>run <code>ssh-keygen -p</code> in a terminal. It will then prompt you for a keyfile (defaulted to the correct file for me, <code>~/.ssh/id_rsa</code>), the old passphrase (enter what you have now) and the new passphrase (enter nothing). </p>
</blockquote>
<p><a href="https://www.ibm.com/support/pages/openssl-wont-understand-rsa-keys-rfc4716-format" target="_blank" rel="external">要注意openssh 不同版本使用的不同 format</a>，用openssh 8.0 默认用 “RFC4716” 格式，老的 4.0 默认是 PKCS8 格式</p>
<p> 去修改dsa密钥后 openssh 4.0 不认 </p>
<blockquote>
<p>-m key_format<br>        Specify a key format for the -i (import) or -e (export) conversion options.  The sup‐<br>        ported key formats are: “RFC4716” (RFC 4716/SSH2 public or private key), “PKCS8” (PEM<br>        PKCS8 public key) or “PEM” (PEM public key).  The default conversion format is<br>        “RFC4716”.</p>
</blockquote>
<p>如果用 8.0 去修改 PKCS8 格式的 key 可以指定格式参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -p  -m &quot;PKCS8&quot; -f ./id_dsa</div></pre></td></tr></table></figure>
<h3 id="ssh-agent"><a href="#ssh-agent" class="headerlink" title="ssh-agent"></a>ssh-agent</h3><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p>
<p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p>
<p>第一步，使用下面的命令新建一次命令行对话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ eval `ssh-agent`</div></pre></td></tr></table></figure>
<p>上面命令中，<code>ssh-agent</code>会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ssh-agent</div><div class="line">SSH_AUTH_SOCK=/tmp/ssh-barrett/ssh-22841-agent; export SSH_AUTH_SOCK;</div><div class="line">SSH_AGENT_PID=22842; export SSH_AGENT_PID;</div><div class="line">echo Agent pid 22842;</div></pre></td></tr></table></figure>
<p><code>eval</code>命令的作用，就是运行上面的<code>ssh-agent</code>命令的输出，设置环境变量。</p>
<p>第二步，在新建的 Shell 对话里面，使用<code>ssh-add</code>命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-add</div><div class="line">Enter passphrase for /home/you/.ssh/id_dsa: ********</div><div class="line">Identity added: /home/you/.ssh/id_dsa (/home/you/.ssh/id_dsa)</div></pre></td></tr></table></figure>
<p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p>
<p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-add my-other-key-file</div></pre></td></tr></table></figure>
<p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p>
<p>SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候用它来解密key chanllge返回给 SSHD  <a href="https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk" target="_blank" rel="external">https://webcache.googleusercontent.com/search?q=cache:7OfvSBFki10J:https://www.ibm.com/developerworks/cn/linux/security/openssh/part2/+&amp;cd=7&amp;hl=en&amp;ct=clnk&amp;gl=hk</a> keychain介绍</p>
<h3 id="安装sshd和debug"><a href="#安装sshd和debug" class="headerlink" title="安装sshd和debug"></a>安装sshd和debug</h3><p>sshd 有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p>
<p>DSA 格式的密钥文件默认为<code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为<code>/etc/ssh/ssh_host_rsa_key</code>（公钥为<code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p>
<p>如果密钥不是默认文件，那么可以通过配置文件<code>sshd_config</code>的<code>HostKey</code>配置项指定。默认密钥的<code>HostKey</code>设置如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># HostKey for protocol version 1</div><div class="line"># HostKey /etc/ssh/ssh_host_key</div><div class="line"></div><div class="line"># HostKeys for protocol version 2</div><div class="line"># HostKey /etc/ssh/ssh_host_rsa_key</div><div class="line"># HostKey /etc/ssh/ssh_host_dsa_ke</div></pre></td></tr></table></figure>
<p>注意，如果重装 sshd，<code>/etc/ssh</code>下的密钥都会重新生成（这些密钥对用于验证Server的身份），导致客户端重新 ssh 连接服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p>
<blockquote>
<p>调试：非后台(-D)和debug(-d)模式启动sshd，同时监听2222和3333端口</p>
<p>sshd -D -d -p 2222 -p 3333</p>
</blockquote>
<p>sshd config 配置多端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#cat /etc/ssh/sshd_config</div><div class="line">Port 22022</div><div class="line">Port 22</div><div class="line">#AddressFamily any</div><div class="line">#ListenAddress 0.0.0.0</div></pre></td></tr></table></figure>
<h3 id="scp设置socks代理"><a href="#scp设置socks代理" class="headerlink" title="scp设置socks代理"></a>scp设置socks代理</h3><blockquote>
<p>scp -o “ProxyCommand=nc -X 5 -x <strong>[SOCKS_HOST]</strong>:<strong>[SOCKS_PORT]</strong> %h %p” <strong>[LOCAL/FILE/PATH]</strong> <strong>[REMOTE_USER]</strong>@<strong>[REMOTE_HOST]</strong>:<strong>[REMOTE/FILE/PATH]</strong></p>
</blockquote>
<p>其中[SOCKS_HOST]和[SOCKS_PORT]是socks代理的LOCAL_ADDRESS和LOCAL_PORT。[LOCAL/FILE/PATH]、[REMOTE_USER]、[REMOTE_HOST]和[REMOTE/FILE/PATH]分别是要复制文件的本地路径、要复制到的远端主机的用户名、要复制到的远端主机名、要复制文件的远端路径，这些参数与不使用代理时一样。“ProxyCommand=nc”表示当前运行命令的主机上需要有nc命令。</p>
<h3 id="ProxyCommand"><a href="#ProxyCommand" class="headerlink" title="ProxyCommand"></a>ProxyCommand</h3><blockquote>
<p>Specifies the proxy command for the connection. This command is launched prior to making the connection to Hostname. %h is replaced with the host defined in HostName and %p is replaced with 22 or is overridden by a Port directive. </p>
</blockquote>
<p>在ssh连接目标主机前先执行ProxyCommand中的命令，比如 .ssh/config 中有如下配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">host remote-host</div><div class="line">ProxyCommand ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc %h %p</div><div class="line"></div><div class="line">//以上配置等价下面的命令</div><div class="line">ssh -o ProxyCommand="ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc %h %p" remote-host</div><div class="line">//or 等价</div><div class="line">ssh -o ProxyCommand="ssh -l root -p 52146 -W %h:%p 1.2.3.4 " remote-host</div><div class="line">//or 等价 debug1: Setting implicit ProxyCommand from ProxyJump: ssh -l root -p 52146 -vvv -W '[%h]:%p' 1.2.3.4</div><div class="line">ssh -J root@1.2.3.4:52146 remote-host</div></pre></td></tr></table></figure>
<p>如上配置指的是，如果执行ssh remote-host 命中host规则，那么先执行命令 ssh -l root -p 52146 1.2.3.4 exec /usr/bin/nc 同时把remote-host和端口(默认22)传给nc</p>
<p>ProxyCommand和ProxyJump很类似，ProxyJump使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//ssh到centos8机器上，走的是gf这台跳板机，本地一般和centos8不通</div><div class="line">ssh -J gf:22 centos8</div></pre></td></tr></table></figure>
<h3 id="ProxyJump"><a href="#ProxyJump" class="headerlink" title="ProxyJump"></a>ProxyJump</h3><p>需要 <code>OpenSSH 7.3</code> 以上版本才可以使用 <code>ProxyJump</code>, 相对 ProxyCommand 更简洁方便些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#ssh 116 就可以通过 jumpserver:50023 连上 root@1.116.2.1:22</div><div class="line">Host 116</div><div class="line">    HostName 1.116.2.1</div><div class="line">    Port 22</div><div class="line">    User root</div><div class="line">    ProxyJump admin@jumpserver:50023</div><div class="line"></div><div class="line">#ssh 1.112.任意ip 都会默认走 jumpserver 跳转过去</div><div class="line">Host 1.112.*.*</div><div class="line">    Port 22</div><div class="line">    User root</div><div class="line">    ProxyJump root@jumpserver</div></pre></td></tr></table></figure>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a><a href="http://www.openssh.com/legacy.html" target="_blank" rel="external">加密算法</a></h3><p>列出本地所支持默认的加密算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#ssh -Q key                                                            </div><div class="line">ssh-ed25519</div><div class="line">ssh-ed25519-cert-v01@openssh.com</div><div class="line">ssh-rsa</div><div class="line">ssh-dss</div><div class="line">ecdsa-sha2-nistp256</div><div class="line">ecdsa-sha2-nistp384</div><div class="line">ecdsa-sha2-nistp521</div><div class="line">ssh-rsa-cert-v01@openssh.com</div><div class="line">ssh-dss-cert-v01@openssh.com</div><div class="line">ecdsa-sha2-nistp256-cert-v01@openssh.com</div><div class="line">ecdsa-sha2-nistp384-cert-v01@openssh.com</div><div class="line">ecdsa-sha2-nistp521-cert-v01@openssh.com</div><div class="line"></div><div class="line">ssh -Q cipher       # List supported ciphers</div><div class="line">ssh -Q mac          # List supported MACs</div><div class="line">ssh -Q key          # List supported public key types</div><div class="line">ssh -Q kex          # List supported key exchange algorithms</div></pre></td></tr></table></figure>
<p>比如连服务器报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">debug1: kex: algorithm: (no match)</div><div class="line">Unable to negotiate with server port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</div></pre></td></tr></table></figure>
<p>表示服务端支持 diffie-hellman-group1-sha1,diffie-hellman-group14-sha1 加密，但是client端不支持，那么可以指定算法来强制client端使用某种和server一致的加密方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ssh  -oKexAlgorithms=+diffie-hellman-group14-sha1 -l user</div><div class="line"></div><div class="line">或者config中配置：</div><div class="line">host server_ip</div><div class="line">KexAlgorithms +diffie-hellman-group1-sha1</div></pre></td></tr></table></figure>
<p>如果仍然报以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">debug2: first_kex_follows 0</div><div class="line">debug2: reserved 0</div><div class="line">debug1: kex: algorithm: diffie-hellman-group14-sha1</div><div class="line">debug1: kex: host key algorithm: (no match)</div><div class="line">Unable to negotiate with server_ip port 22: no matching host key type found. Their offer: ssh-rsa</div></pre></td></tr></table></figure>
<p>那么可以配置来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Host *</div><div class="line">    HostKeyAlgorithms +ssh-rsa</div><div class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</div></pre></td></tr></table></figure>
<p>When an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="external">ssh_config</a> keyword:</p>
<ul>
<li><code>KexAlgorithms</code>: the key exchange methods that are used to generate per-connection keys</li>
<li><code>HostkeyAlgorithms</code>: the public key algorithms accepted for an SSH server to authenticate itself to an SSH client</li>
<li><code>Ciphers</code>: the ciphers to encrypt the connection</li>
<li><code>MACs</code>: the message authentication codes used to detect traffic modification</li>
</ul>
<h2 id="无所不能的-SSH-三大转发模式"><a href="#无所不能的-SSH-三大转发模式" class="headerlink" title="无所不能的 SSH 三大转发模式"></a>无所不能的 SSH 三大转发模式</h2><p>了解完前面的一些小知识，再来看看无所不能的三大杀招。上面的各种代理基本都是由这三种转发模式实现的。</p>
<p>SSH能够做动态转发、本地转发、远程转发。先简要概述下他们的特点和使用场景</p>
<p><strong><a href="https://www.skywind.me/blog/archives/2546" target="_blank" rel="external">三个转发模式的比较</a>：</strong></p>
<ul>
<li>动态转发完全可以代替本地转发，只是动态转发是<code>socks5协议</code>，当科学上网用，本地转发是tcp协议</li>
<li>本地转发完全是把动态转发特例化到访问某个固定目标的转发，类似  iptable 的 port forwarding</li>
<li>远程转发是启动转端口的机器同时连上两端的两个机器，把本来不连通的两端拼接起来，中间显得多了个节点。</li>
<li>三个转发模式可以串联使用</li>
</ul>
<p>动态转发常用来科学上网，本地转发用来打洞，这两种转发启动的端口都是在本地；远程转发也是打洞的一种，只不过启用的端口在远程机器上。</p>
<p><img src="/images/951413iMgBlog/ssh-tunnels.png" alt="img"></p>
<h3 id="动态转发-D-SOCKS5-协议"><a href="#动态转发-D-SOCKS5-协议" class="headerlink" title="动态转发 (-D)   SOCKS5 协议"></a>动态转发 (-D)   SOCKS5 协议</h3><p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p>
<p>动态转发需要把本地端口绑定到 SSH 服务器。<strong>至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发</strong>。</p>
<p>动态的意思就是：需要访问的目标、端口还不确定。后面要讲的本地转发、远程转发都是针对具体IP、port的转发。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ssh -D 4444 ssh-server -N</div><div class="line">//或者如下方式：</div><div class="line">nohup ssh -qTfnN -D *:13658 root@jump vmstat 10  &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。<code>-N</code>参数表示，这个 SSH 连接不能执行远程命令，只能充当隧道。</p>
<p><img src="/images/951413iMgBlog/image-20210913143129749.png" alt="image-20210913143129749"></p>
<p>下面是 ssh 隧道建立后的一个<strong>使用实例</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -x socks5://localhost:4444 http://www.example.com</div><div class="line">or</div><div class="line">curl --socks5-hostname localhost:4444 https://www.twitter.com</div></pre></td></tr></table></figure>
<p>上面命令中，curl 的<code>-x</code>参数指定代理服务器，即通过 SOCKS5 协议的本地<code>3000</code>端口，访问<code>http://www.example.com</code>。</p>
<p>官方文档关于 -D的介绍</p>
<blockquote>
<p>-D [bind_address:]port<br>         Specifies a local “dynamic” application-level port forwarding.  This works by allocat‐<br>             ing a socket to listen to port on the local side, optionally bound to the specified<br>             bind_address.  Whenever a connection is made to this port, the connection is forwarded<br>             over the secure channel, and the application protocol is then used to determine where<br>             to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are<br>             supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.<br>             Dynamic port forwardings can also be specified in the configuration file.</p>
</blockquote>
<p>特别注意，如果ssh -D 要启动的本地port已经被占用了是不会报错的，但是实际socks代理会没启动成功</p>
<h3 id="本地转发-L"><a href="#本地转发-L" class="headerlink" title="本地转发 (-L)"></a>本地转发 (-L)</h3><p>本地转发（local forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定<code>目标网站</code>之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p>
<p>典型使用场景就是，打洞，经过跳板机访问无法直接连通的服务。</p>
<p>它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（ssh-server），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ssh -L :local-port:target-host:target-port ssh-server  //target-host是ssh-server的target-host, target-host 域名解析、路由都是由ssh-server完成</div></pre></td></tr></table></figure>
<p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>ssh-server</code>是 SSH 跳板机。当你访问localhost:local-port 的时候会通过ssh-server把请求转给target-host:target-port</p>
<p><img src="/images/951413iMgBlog/vgaakWbKC9OPXugAR9oPnotTq1L4jBRDEg.JPG" alt="img"></p>
<p>上图对应的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 53682:remote-server:53682 ssh-server</div></pre></td></tr></table></figure>
<p>然后，访问本机的53682端口，就是访问<code>remote-server</code>的53682端口.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl http://localhost:53682</div></pre></td></tr></table></figure>
<p>注意，<strong>本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议</strong>。如果需要HTTP的动态代理，可以先起socks5动态代理，然后再起一个本地转发给动态代理的socks5端口，这样就有一个HTTP代理了，能给yum、docker之类的使用。</p>
<p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p>
<p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Host test.example.com</div><div class="line">LocalForward client-IP:client-port server-IP:server-port</div></pre></td></tr></table></figure>
<h3 id="远程转发-R"><a href="#远程转发-R" class="headerlink" title="远程转发(-R)"></a>远程转发(-R)</h3><p>远程端口指的是在远程 SSH 服务器建立的转发规则。主要是执行ssh转发的机器别人连不上，所以需要一台client能连上的机器当远程转发端口，要不就是本地转发了。</p>
<p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -fNR 30.1.2.3:30081:166.100.64.1:3128 root@30.1.2.3 -p 2728</div></pre></td></tr></table></figure>
<p>上面的命令，首先需要注意，<strong>不是在30.1.2.3 或者166.100.64.1 上执行的，而是找一台能联通 30.1.2.3 和166.100.64.1的机器来执行</strong>，在执行前Remote clients能连上 30.1.2.3 但是 30.1.2.3 和 166.100.64.1 不通，所以需要一个中介将 30.1.2.3 和166.100.64.1打通，这个中介就是下图中的MobaXterm所在的机器，命令在MobaXterm机器上执行</p>
<p><img src="/images/951413iMgBlog/image-20210913163036410.png" alt="image-20210913163036410"></p>
<p>执行上面的命令以后，跳板机30.1.2.3 到166.100.64.1的隧道已经建立了，这个隧道是依赖两边都能连通的MobaXterm机器。然后，就可以从Remote Client访问目标服务器了，即在Remote Client上执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl http://30.1.2.3:30081</div></pre></td></tr></table></figure>
<p>执行上面的命令以后，命令就会输出服务器 166.100.64.1 的3128端口返回的内容。</p>
<p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Host test.example.com</div><div class="line">RemoteForward local-IP:local-port target-ip:target-port</div></pre></td></tr></table></figure>
<p>注意远程转发需要：</p>
<blockquote>
<ol>
<li>sshd_config里要打开<code>AllowTcpForwarding</code>选项，否则<code>-R</code>远程端口转发会失败。</li>
<li>默认转发到远程主机上的端口绑定的是<code>127.0.0.1</code>，<a href="https://serverfault.com/questions/997124/ssh-r-binds-to-127-0-0-1-only-on-remote" target="_blank" rel="external">如要绑定<code>0.0.0.0</code>需要打开sshd_config里的<code>GatewayPorts</code>选项(然后ssh -R 后加上*:port )</a>。这个选项如果由于权限没法打开也有办法，可配合<code>ssh -L</code>将端口绑定到<code>0.0.0.0</code>。</li>
</ol>
</blockquote>
<p>开通远程转发后，如果需要动态代理（比如访问所有web服务），那么可以在30081端口机器上(30.1.2.3)执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssh -qTfnN -D *:13658 root@127.0.0.1 -p 30081 vmstat 10  &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>表示在30081机器上(30.1.2.3)启动了一个socks5动态代理服务</p>
<h2 id="调试转发、代理是否能联通"><a href="#调试转发、代理是否能联通" class="headerlink" title="调试转发、代理是否能联通"></a>调试转发、代理是否能联通</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a><a href="https://docs.google.com/document/d/1lSeScMYw9I7Pj_OgXEugfwp-taeF4b72WF_CGp4ey5s/edit#heading=h.n7jhdk88a6rk" target="_blank" rel="external">curl</a></h3><blockquote>
<p>curl -I –socks5-hostname localhost:13659 twitter.com</p>
<p>curl -x socks5://localhost:13659 twitter.com</p>
</blockquote>
<p>Suppose you have a socks5 proxy running on localhost:13659 . </p>
<p><a href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="external">In curl &gt;= 7.21.7, you can use</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -x socks5h://localhost:13659 http://www.google.com/</div></pre></td></tr></table></figure>
<p>In a proxy string, socks5h:// and socks4a:// mean that the hostname is<br>resolved by the SOCKS server. socks5:// and socks4:// mean that the<br>hostname is resolved locally. socks4a:// means to use SOCKS4a, which is<br>an extension of SOCKS4. Let’s make urllib3 honor it.</p>
<p>In curl &gt;= 7.18.0, you can use</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl --socks5-hostname localhost:13659 http://www.google.com/</div></pre></td></tr></table></figure>
<p>–proxy 参数含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The --socks5 option is basically considered obsolete since curl 7.21.7. This is because starting in that release, you can now specify the proxy protocol directly in the string that you specify the proxy host name and port number with already. The server you specify with --proxy. If you use a socks5:// scheme, curl will go with SOCKS5 with local name resolve but if you instead use socks5h:// it will pick SOCKS5 with proxy-resolved host name.</div></pre></td></tr></table></figure>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p><strong>指定命令行参数</strong>,通过命令行指定HTTP代理服务器的方式如下：</p>
<blockquote>
<p>wget -Y on -e “http_proxy=<a href="http://**[HTTP_HOST]**:**[HTTP_PORT]**" target="_blank" rel="external">http://**[HTTP_HOST]**:**[HTTP_PORT]**</a>“ <a href="http://facebook.com/其中：[HTTP_HOST]和[HTTP_PORT]是http" target="_blank" rel="external">http://facebook.com/其中：[HTTP_HOST]和[HTTP_PORT]是http</a> proxy的ADDRESS和PORT。</p>
</blockquote>
<p>-Y表示是否使用代理，on表示使用代理。</p>
<p>-e执行后面跟的命令，相当于在.wgetrc配置文件中添加了一条命令，将http_proxy设置为需要使用的代理服务器。</p>
<p>wget –limit-rate=2.5k 限制下载速度，进行测试</p>
<h2 id="PKI-Public-Key-Infrastructure-证书"><a href="#PKI-Public-Key-Infrastructure-证书" class="headerlink" title="PKI (Public Key Infrastructure)证书"></a>PKI (Public Key Infrastructure)证书</h2><p>X.509 只是一种常用的证书格式，一般以PEM编码，PEM 编码的证书通常以 <strong><code>.pem</code>、<code>.crt</code> 或 <code>.cer</code></strong> 为后缀。再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。通过pem证书可以访问需要认证的https服务(比如etcd、apiserver等)</p>
<ul>
<li><strong>ASN.1 用于定义数据类型</strong>，例如证书（certificate）和秘钥（key）——就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。</li>
<li>DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。</li>
<li>PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。</li>
<li>DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它用 base64 对 DER 进行编码，然后再加上自己的 label。</li>
<li>私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。</li>
</ul>
<p>通过命令 cat /etc/kubernetes/pki/ca.crt | openssl x509 -text  也可以得到下图信息</p>
<p><img src="/images/951413iMgBlog/step-certificate-inspect.png" alt="image"></p>
<h3 id="公钥、私钥常见扩展名"><a href="#公钥、私钥常见扩展名" class="headerlink" title="公钥、私钥常见扩展名"></a>公钥、私钥常见扩展名</h3><ul>
<li>公钥：<code>.pub</code> or <code>.pem</code>，<code>ca.crt</code></li>
<li>私钥：<code>.prv,</code> <code>.key</code>, or <code>.pem</code> , <code>ca.key</code>。</li>
</ul>
<h3 id="证书生成过程演示"><a href="#证书生成过程演示" class="headerlink" title="证书生成过程演示"></a>证书生成过程演示</h3><p>并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 <code>openssl</code>命令来演示这个过程。</p>
<p>1）生成 CA 机构的证书（公钥） <code>ca.crt</code> 和私钥 <code>ca.key</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">openssl req -newkey rsa:2048 \</div><div class="line">    -new -nodes -x509 \</div><div class="line">    -days 365 \</div><div class="line">    -out ca.crt \</div><div class="line">    -keyout ca.key \</div><div class="line">    -subj &quot;/C=SO/ST=Earth/L=Mountain/O=CoolShell/OU=HQ/CN=localhost&quot;</div></pre></td></tr></table></figure>
<p>2) 生成 alice 的私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out alice.key 2048</div></pre></td></tr></table></figure>
<p>3）生成 Alice 的 CSR – Certificate Signing Request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl req -new -key alice.key -days 365 -out alice.csr \</div><div class="line">    -subj &quot;/C=CN/ST=Beijing/L=Haidian/O=CoolShell/OU=Test/CN=localhost.alice&quot;</div></pre></td></tr></table></figure>
<p>4）使用 CA 给 Alice 签名证书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">openssl x509  -req -in alice.csr \</div><div class="line">    -extfile &lt;(printf &quot;subjectAltName=DNS:localhost.alice&quot;) \ </div><div class="line">    -CA ca.crt -CAkey ca.key  \</div><div class="line">    -days 365 -sha256 -CAcreateserial \</div><div class="line">    -out alice.crt</div></pre></td></tr></table></figure>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://docs.corp-inc.com/pages/editpage.action?pageId=203555361" target="_blank" rel="external">http://docs.corp-inc.com/pages/editpage.action?pageId=203555361</a><br><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</p>
<p><a href="https://wangdoc.com/ssh/key.html" target="_blank" rel="external">https://wangdoc.com/ssh/key.html</a></p>
<p><a href="https://robotmoon.com/ssh-tunnels/" target="_blank" rel="external">https://robotmoon.com/ssh-tunnels/</a></p>
<p><a href="https://blog.gwlab.page/vpn-over-ssh-the-socks-proxy-8a8d7bdc7028" target="_blank" rel="external">通过SSH动态转发来建立Socks代以及各种场景应用案例</a></p>
<p><a href="https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/" target="_blank" rel="external">https://daniel.haxx.se/blog/2020/05/26/curl-ootw-socks5/</a></p>
<p><a href="http://www.allanjude.com/bsd/AsiaBSDCon2017_-_SSH_Performance.pdf" target="_blank" rel="external">SSH Performance</a></p>
<p><a href="https://stackoverflow.com/questions/8849240/why-when-i-transfer-a-file-through-sftp-it-takes-longer-than-ftp" target="_blank" rel="external">Why when I transfer a file through SFTP, it takes longer than FTP?</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/413732839" target="_blank" rel="external">一行代码解决scp在Internet传输慢的问题</a></p>
<p><a href="https://www.cnxct.com/everything-about-pki-zh/" target="_blank" rel="external">关于证书（certificate）和公钥基础设施（PKI）的一切</a></p>
<p><a href="https://coolshell.cn/articles/21708.html" target="_blank" rel="external">网络数字身份认证术</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/SSH/" rel="tag"># SSH</a>
          
            <a href="/tags/password/" rel="tag"># password</a>
          
            <a href="/tags/forward/" rel="tag"># forward</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/26/MySQL知识体系的三驾马车/" rel="next" title="MySQL知识体系的三驾马车">
                <i class="fa fa-chevron-left"></i> MySQL知识体系的三驾马车
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/09/一文搞懂域名解析相关问题/" rel="prev" title="就是要你懂DNS--一文搞懂域名解析相关问题">
                就是要你懂DNS--一文搞懂域名解析相关问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="twitter @plantegg" />
          <p class="site-author-name" itemprop="name">twitter @plantegg</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">151</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">244</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#史上最全-SSH-暗黑技巧详解"><span class="nav-number">1.</span> <span class="nav-text">史上最全 SSH 暗黑技巧详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#本文试图解决的问题"><span class="nav-number">1.1.</span> <span class="nav-text">本文试图解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">1.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#科学上网"><span class="nav-number">1.3.</span> <span class="nav-text">科学上网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#科学上网之http特殊代理–利用ssh-本地转发是HTTP协议"><span class="nav-number">1.3.1.</span> <span class="nav-text">科学上网之http特殊代理–利用ssh 本地转发是HTTP协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部堡垒机、跳板机都需要密码-动态码，太复杂了，怎么解？"><span class="nav-number">1.4.</span> <span class="nav-text">内部堡垒机、跳板机都需要密码+动态码，太复杂了，怎么解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？"><span class="nav-number">1.5.</span> <span class="nav-text">我有很多不同机房（或者说不同客户）的机器都需要跳板机来登录，能一次直接ssh上去吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将隔离环境中的web端口映射到本地（本地代理）"><span class="nav-number">1.6.</span> <span class="nav-text">将隔离环境中的web端口映射到本地（本地代理）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么有时候ssh-比较慢，比如总是需要30秒钟后才能正常登录"><span class="nav-number">1.7.</span> <span class="nav-text">为什么有时候ssh 比较慢，比如总是需要30秒钟后才能正常登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批量打通所有机器之间的ssh登录免密码"><span class="nav-number">1.8.</span> <span class="nav-text">批量打通所有机器之间的ssh登录免密码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？"><span class="nav-number">1.9.</span> <span class="nav-text">留个作业：第一次ssh某台机器的时候总是出来一个警告，需要yes确认才能往下走，怎么干掉他？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ssh-config-参考配置"><span class="nav-number">1.10.</span> <span class="nav-text">~/.ssh/config 参考配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#etc-ssh-ssh-config-参考配置"><span class="nav-number">1.11.</span> <span class="nav-text">/etc/ssh/ssh_config 参考配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他知识点"><span class="nav-number">1.12.</span> <span class="nav-text">其他知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#永久隧道"><span class="nav-number">1.12.1.</span> <span class="nav-text">永久隧道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试ssh–终极大招"><span class="nav-number">1.12.2.</span> <span class="nav-text">调试ssh–终极大招</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ssh-提示信息"><span class="nav-number">1.12.3.</span> <span class="nav-text">ssh 提示信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sshd-Banner"><span class="nav-number">1.12.4.</span> <span class="nav-text">sshd Banner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证秘钥对"><span class="nav-number">1.12.5.</span> <span class="nav-text">验证秘钥对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#github-上你的公钥"><span class="nav-number">1.12.6.</span> <span class="nav-text">github 上你的公钥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ssh-keygen"><span class="nav-number">1.12.7.</span> <span class="nav-text">ssh-keygen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ssh-agent"><span class="nav-number">1.12.8.</span> <span class="nav-text">ssh-agent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装sshd和debug"><span class="nav-number">1.12.9.</span> <span class="nav-text">安装sshd和debug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scp设置socks代理"><span class="nav-number">1.12.10.</span> <span class="nav-text">scp设置socks代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyCommand"><span class="nav-number">1.12.11.</span> <span class="nav-text">ProxyCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProxyJump"><span class="nav-number">1.12.12.</span> <span class="nav-text">ProxyJump</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加密算法"><span class="nav-number">1.12.13.</span> <span class="nav-text">加密算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无所不能的-SSH-三大转发模式"><span class="nav-number">1.13.</span> <span class="nav-text">无所不能的 SSH 三大转发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态转发-D-SOCKS5-协议"><span class="nav-number">1.13.1.</span> <span class="nav-text">动态转发 (-D)   SOCKS5 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地转发-L"><span class="nav-number">1.13.2.</span> <span class="nav-text">本地转发 (-L)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程转发-R"><span class="nav-number">1.13.3.</span> <span class="nav-text">远程转发(-R)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试转发、代理是否能联通"><span class="nav-number">1.14.</span> <span class="nav-text">调试转发、代理是否能联通</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#curl"><span class="nav-number">1.14.1.</span> <span class="nav-text">curl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wget"><span class="nav-number">1.14.2.</span> <span class="nav-text">wget</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PKI-Public-Key-Infrastructure-证书"><span class="nav-number">1.15.</span> <span class="nav-text">PKI (Public Key Infrastructure)证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#公钥、私钥常见扩展名"><span class="nav-number">1.15.1.</span> <span class="nav-text">公钥、私钥常见扩展名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#证书生成过程演示"><span class="nav-number">1.15.2.</span> <span class="nav-text">证书生成过程演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料："><span class="nav-number">1.16.</span> <span class="nav-text">参考资料：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">twitter @plantegg</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv_footer"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv_footer"></span>人次
</span>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
